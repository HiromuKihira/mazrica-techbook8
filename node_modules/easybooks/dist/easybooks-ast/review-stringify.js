"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getId = (context) => {
    const id = context.id++;
    return `${context.chapter}-${id.toString().padStart(3, '0')}`;
};
const root = (tree, context) => {
    return tree.children.map(child => exports.compiler(child, context)).join('\n');
};
const heading = (tree, context) => {
    const s = tree.children
        .map(child => exports.compiler(child, context))
        .join('')
        .trim();
    const option = tree.options.length === 0 ? '' : `[${tree.options.join(',')}]`;
    return `${'='.repeat(tree.depth)}${option} ${s}\n`;
};
const text = (tree) => {
    return tree.value;
};
const paragraph = (tree, context) => {
    return `\n${tree.children
        .map(child => exports.compiler(child, context))
        .join('')}\n`;
};
const inlineCode = (tree) => {
    return `@<code>{${tree.value.replace('}', '\\}')}}`;
};
const breakNode = () => {
    return `\n`;
};
const code = (tree, context) => {
    const lang = tree.lang ? `[${tree.lang}]` : '';
    if (tree.lang === 'sh') {
        return `//cmd{\n${tree.value}\n//}\n`;
    }
    return `//listnum[${(tree.id || getId(context)).replace('}', '\\}')}][${tree.caption || ''}]${lang}{\n${tree.value}\n//}\n`;
};
const link = (tree, context) => {
    const s = tree.children.map(child => exports.compiler(child, context)).join('');
    return `@<href>{${tree.url}${s ? `, ${s}` : ''}}`;
};
const linkReference = (tree, context) => {
    const [tag, id] = tree.identifier.split(':');
    if (tag !== '' && id !== '') {
        return `@<${tag}>{${id.replace('}', '\\}')}}`;
    }
    throw new Error('linkRef: [tag:id] format is only supported.');
};
const list = (tree, context) => {
    return (tree.children
        .map(child => exports.compiler(child, { ...context, list: context.list + 1 }))
        .join('') + '\n');
};
const listItem = (tree, context) => {
    return ` ${'*'.repeat(context.list)} ${tree.children
        .map(child => exports.compiler(child, context))
        .join('')
        .trim()}\n`;
};
const ignore = (tree, context) => '';
const blockquote = (tree, context) => {
    return `//quote{\n${tree.children.map(child => exports.compiler(child, context))}//}\n`;
};
const footnoteReference = (tree, context) => {
    return `@<fn>{${tree.identifier}}`;
};
const footnoteDefinition = (tree, context) => {
    return `//footnote[${tree.identifier}][${tree.children
        .map(child => exports.compiler(child, context))
        .join('')
        .trim()}]\n`;
};
const emphasis = (tree, context) => {
    return `@<em>{${tree.children.map(child => exports.compiler(child, context))}}`;
};
const strong = (tree, context) => {
    return `@<strong>{${tree.children.map(child => exports.compiler(child, context))}}`;
};
const comment = (tree, context) => {
    return tree.value
        .trim()
        .split('\n')
        .map(line => `#@# ${line}`)
        .join('\n');
};
const image = (tree, context) => {
    const url = tree.url
        .replace(/^images\//, '')
        .replace(/\.[a-zA-Z0-9]$/, '');
    return `//image[${url}][${tree.alt}]\n`;
};
const TableAlign = {
    left: 'l',
    center: 'c',
    right: 'r',
};
const table = (tree, context) => {
    const [header, ...rows] = tree.children.map(child => exports.compiler(child, context));
    const lines = [];
    if (tree.align) {
        lines.push(`//tsize[|latex||${tree.align
            .map(align => TableAlign[align || 'left'])
            .join('|')}|]`);
    }
    // FIXME: caption!!!!
    lines.push(`//table[${getId(context)}][]{`);
    lines.push(header);
    lines.push('--------------------------');
    lines.push(...rows);
    lines.push('//}');
    lines.push('');
    return lines.join('\n');
};
const tableRow = (tree, context) => {
    return tree.children.map(child => exports.compiler(child, context)).join('\t');
};
const tableCell = (tree, context) => {
    return tree.children.map(child => exports.compiler(child, context)).join('');
};
const div = (tree, context) => {
    return `//${tree.className}{\n${tree.value}\n//}\n`;
};
const compilers = {
    root,
    paragraph,
    heading,
    thematicBreak: ignore,
    blockquote,
    text,
    inlineCode,
    break: breakNode,
    code,
    link,
    linkReference,
    list,
    listItem,
    footnoteReference,
    footnoteDefinition,
    emphasis,
    strong,
    image,
    table,
    tableRow,
    tableCell,
    comment,
    div,
};
exports.compiler = (tree, context) => {
    if (tree.type in compilers) {
        const key = tree.type;
        return compilers[key](tree, context);
    }
    else {
        console.log(tree);
        throw new Error(`Not implemented: ${tree.type}`);
    }
};
function mdToReview() {
    // @ts-ignore
    this.Compiler = (tree, vfile) => {
        return exports.compiler(tree, {
            list: 0,
            id: 0,
            chapter: typeof vfile.data === 'string' ? vfile.data : '',
        });
    };
}
exports.default = mdToReview;
//# sourceMappingURL=review-stringify.js.map