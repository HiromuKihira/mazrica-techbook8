"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getId = (context) => {
    const id = context.id++;
    return `${context.chapter}-${id.toString().padStart(3, '0')}`;
};
const escape = (s) => {
    return s
        .replace('#', '#')
        .replace('%', '%')
        .replace('&', '&')
        .replace('{', '\\{')
        .replace('}', '\\}')
        .replace('-', '{-}')
        .replace('$', '\textdollar{}')
        .replace('_', '\\textunderscore{}')
        .replace('|', '\\textbar{}')
        .replace('^', '\\textasciicircum{}')
        .replace('~', '\\textasciitilde{}')
        .replace('<', '\\textless{}')
        .replace('>', '\\textgreater{}')
        .replace('\\', '\\reviewbackslash{}');
};
const root = (tree, context) => {
    return tree.children.map(child => exports.compiler(child, context)).join('\n');
};
const heading = (tree, context) => {
    const options = [];
    const s = tree.children
        .map(child => {
        if (child.type === 'linkReference') {
            options.push(child.identifier);
        }
        else {
            return exports.compiler(child, context);
        }
    })
        .join('')
        .trim();
    const option = options.length === 0 ? '' : `[${options.join(',')}]`;
    switch (tree.depth) {
        case 1: {
            return `\\chapter{${escape(s)}}\n`;
        }
        case 2: {
            return `\\section{${escape(s)}}\n`;
        }
        case 3: {
            return `\\subsection{${escape(s)}}\n`;
        }
        case 4: {
            return `\\subsubsection(${escape(s)}}\n`;
        }
        case 5: {
            return `\\paragraph(${escape(s)}}\n`;
        }
        case 6: {
            return `\\subparagraph(${escape(s)}}\n`;
        }
        default: {
            throw new Error(`unkonwn level ${tree.depth}`);
        }
    }
};
const text = (tree) => {
    return escape(tree.value);
};
const paragraph = (tree, context) => {
    return `\n${tree.children.map(child => exports.compiler(child, context)).join('')}\n`;
};
const inlineCode = (tree) => {
    return `\\reviewcode{${escape(tree.value)}}`;
};
const breakNode = () => {
    return `\n`;
};
const code = (tree, context) => {
    const lang = tree.lang ? `[${tree.lang}]` : '';
    if (lang === 'sh') {
        const lines = [];
        lines.push('\\begin{reviewlistblock}');
        lines.push('\\begin{reviewcmd}');
        lines.push(escape(tree.value));
        lines.push('\\end{reviewcmd}');
        lines.push('\\end{reviewlistblock}');
        return lines.join('\n');
    }
    const lines = [];
    lines.push('\\begin{reviewlistblock}');
    if (tree.caption) {
        lines.push(`\\reviewlistcaption{リスト****${escape(tree.caption)}}`);
    }
    lines.push('\\begin{reviewlist}');
    lines.push(escape(tree.value));
    lines.push('\\end{reviewlist}');
    lines.push('\\end{reviewlistblock}');
    return lines.join('\n');
    /*
    return `//listnum[${(meta.id || getId(context)).replace(
      '}',
      '\\}',
    )}][${meta.caption || ''}]${lang}{\n${tree.value}\n//}\n`
  */
};
const link = (tree, context) => {
    const s = tree.children.map(child => exports.compiler(child, context)).join('');
    return `@<href>{${tree.url}${s ? `, ${s}` : ''}}`;
};
const linkReference = (tree, context) => {
    const [tag, id] = tree.identifier.split(':');
    if (tag !== '' && id !== '') {
        return `@<${tag}>{${id.replace('}', '\\}')}}`;
    }
    throw new Error('linkRef: [tag:id] format is only supported.');
};
const list = (tree, context) => {
    return (tree.children
        .map(child => exports.compiler(child, { ...context, list: context.list + 1 }))
        .join('') + '\n');
};
const listItem = (tree, context) => {
    return ` ${'*'.repeat(context.list)} ${tree.children
        .map(child => exports.compiler(child, context))
        .join('')
        .trim()}\n`;
};
const ignore = (tree, context) => '';
const blockquote = (tree, context) => {
    return `//quote{\n${tree.children.map(child => exports.compiler(child, context))}}\n`;
};
const footnoteReference = (tree, context) => {
    return `@<fn>{${tree.identifier}}`;
};
const footnoteDefinition = (tree, context) => {
    return `//footnote[${tree.identifier}][${tree.children
        .map(child => exports.compiler(child, context))
        .join('')
        .trim()}]\n`;
};
const emphasis = (tree, context) => {
    return `@<em>{${tree.children.map(child => exports.compiler(child, context))}}`;
};
const strong = (tree, context) => {
    return `@<strong>{${tree.children.map(child => exports.compiler(child, context))}}`;
};
const html = (tree, context) => {
    if (tree.value.startsWith('<!--')) {
        return tree.value
            .replace(/^<!--/, '')
            .replace(/-->$/, '')
            .trim()
            .split('\n')
            .map(line => `#@# ${line}`)
            .join('\n');
    }
    else {
        throw new Error(`supported HTML is comment only.\n${tree.value}`);
    }
};
const image = (tree, context) => {
    const url = tree.url.replace(/^images\//, '').replace(/\.[a-zA-Z0-9]$/, '');
    return `//image[${url}][${tree.alt}]\n`;
};
const TableAlign = {
    left: 'l',
    center: 'c',
    right: 'r',
};
const table = (tree, context) => {
    const [header, ...rows] = tree.children.map(child => exports.compiler(child, context));
    const lines = [];
    if (tree.align) {
        lines.push(`//tsize[|latex||${tree.align
            .map(align => TableAlign[align || 'left'])
            .join('|')}|]`);
    }
    // FIXME: caption!!!!
    lines.push(`//table[${getId(context)}][]{`);
    lines.push(header);
    lines.push('--------------------------');
    lines.push(...rows);
    lines.push('//}');
    lines.push('');
    return lines.join('\n');
};
const tableRow = (tree, context) => {
    return tree.children.map(child => exports.compiler(child, context)).join('\t');
};
const tableCell = (tree, context) => {
    return tree.children.map(child => exports.compiler(child, context)).join('');
};
const compilers = {
    root,
    paragraph,
    heading,
    thematicBreak: ignore,
    blockquote,
    text,
    inlineCode,
    break: breakNode,
    code,
    link,
    linkReference,
    list,
    listItem,
    footnoteReference,
    footnoteDefinition,
    emphasis,
    strong,
    html,
    image,
    table,
    tableRow,
    tableCell,
};
exports.compiler = (tree, context) => {
    if (tree.type in compilers) {
        const key = tree.type;
        return compilers[key](tree, context);
    }
    else {
        console.log(tree);
        throw new Error(`Not implemented: ${tree.type}`);
    }
};
function mdToTex() {
    // @ts-ignore
    this.Compiler = (tree, vfile) => {
        return exports.compiler(tree, {
            list: 0,
            id: 0,
            chapter: typeof vfile.data === 'string' ? vfile.data : '',
        });
    };
}
exports.default = mdToTex;
//# sourceMappingURL=tex-stringify.js.map