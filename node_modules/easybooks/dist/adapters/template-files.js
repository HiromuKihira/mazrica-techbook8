"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const crypto_1 = require("crypto");
const node_fetch_1 = __importDefault(require("node-fetch"));
const jszip_1 = __importDefault(require("jszip"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const writeFile = util_1.promisify(fs_1.default.writeFile);
const readFile = util_1.promisify(fs_1.default.readFile);
const getHash = (buf) => {
    const sha256 = crypto_1.createHash('sha256');
    sha256.write(buf);
    return sha256.digest().toString('hex');
};
exports.createFetchTemplatesPort = ({ cacheDir }) => {
    const fetchTemplates = async (url, dir) => {
        const cacheFilename = path_1.default.join(cacheDir, `${getHash(url)}.zip`);
        const tasks = [];
        let buf;
        try {
            buf = new Uint8Array(await readFile(cacheFilename)).buffer;
            console.log('read from cache');
        }
        catch (e) {
            if (e.code !== 'ENOENT') {
                throw e;
            }
            console.log('fetch');
            const res = await node_fetch_1.default(url);
            buf = await res.arrayBuffer();
            mkdirp_1.default.sync(path_1.default.dirname(cacheFilename));
            await writeFile(cacheFilename, Buffer.from(buf));
        }
        const zip = new jszip_1.default();
        await zip.loadAsync(buf);
        zip.forEach((relPath, file) => {
            if (!relPath.startsWith(dir) || relPath === dir) {
                return;
            }
            tasks.push(new Promise((resolve, reject) => {
                let text = '';
                const st = file.nodeStream();
                st.on('data', data => (text += data.toString()));
                st.on('error', err => reject(err));
                st.on('end', () => resolve({ text, name: relPath.slice(dir.length) }));
            }));
        });
        return Promise.all(tasks);
    };
    return { fetch: fetchTemplates };
};
//# sourceMappingURL=template-files.js.map